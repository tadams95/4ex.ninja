"""
MongoDB Signal Repository Implementation - Concrete implementation for Signal entities

This module provides the MongoDB-specific implementation of the Signal repository,
extending the base MongoDB repository with Signal-specific operations.
"""

from typing import List, Optional, Dict, Any
from datetime import datetime, timedelta
from decimal import Decimal
import logging

from .mongo_base_repository import MongoBaseRepository
from ...core.interfaces.signal_repository import ISignalRepository
from ...core.entities.signal import Signal, SignalType, SignalStatus
from ...core.interfaces.repository import RepositoryError

logger = logging.getLogger(__name__)


class MongoSignalRepository(MongoBaseRepository[Signal], ISignalRepository):
    """
    MongoDB implementation of the Signal repository.

    Extends the base MongoDB repository with Signal-specific query operations.
    """

    def __init__(self, database: Any):
        """
        Initialize the Signal repository.

        Args:
            database: MongoDB database instance
        """
        super().__init__(database, "signals", Signal)

    async def get_by_strategy_id(
        self, strategy_id: str, limit: Optional[int] = None
    ) -> List[Signal]:
        """Get all signals generated by a specific strategy."""
        try:
            filters = {"strategy_id": strategy_id}
            return await self.find_by_criteria(
                filters=filters, limit=limit, sort_by="created_at", sort_order="desc"
            )
        except Exception as e:
            raise RepositoryError(
                f"Failed to get signals by strategy ID {strategy_id}", original_error=e
            )

    async def get_by_pair(self, pair: str, limit: Optional[int] = None) -> List[Signal]:
        """Get all signals for a specific currency pair."""
        try:
            filters = {"pair": pair}
            return await self.find_by_criteria(
                filters=filters, limit=limit, sort_by="created_at", sort_order="desc"
            )
        except Exception as e:
            raise RepositoryError(
                f"Failed to get signals by pair {pair}", original_error=e
            )

    async def get_by_status(
        self, status: SignalStatus, limit: Optional[int] = None
    ) -> List[Signal]:
        """Get all signals with a specific status."""
        try:
            filters = {"status": status}
            return await self.find_by_criteria(
                filters=filters, limit=limit, sort_by="created_at", sort_order="desc"
            )
        except Exception as e:
            raise RepositoryError(
                f"Failed to get signals by status {status}", original_error=e
            )

    async def get_by_type(
        self, signal_type: SignalType, limit: Optional[int] = None
    ) -> List[Signal]:
        """Get all signals of a specific type."""
        try:
            filters = {"signal_type": signal_type}
            return await self.find_by_criteria(
                filters=filters, limit=limit, sort_by="created_at", sort_order="desc"
            )
        except Exception as e:
            raise RepositoryError(
                f"Failed to get signals by type {signal_type}", original_error=e
            )

    async def get_active_signals(self, limit: Optional[int] = None) -> List[Signal]:
        """Get all currently active signals."""
        try:
            filters = {"status": SignalStatus.ACTIVE}
            return await self.find_by_criteria(
                filters=filters, limit=limit, sort_by="created_at", sort_order="desc"
            )
        except Exception as e:
            raise RepositoryError("Failed to get active signals", original_error=e)

    async def get_recent_signals(
        self, hours: int = 24, limit: Optional[int] = None
    ) -> List[Signal]:
        """Get signals generated within the last specified hours."""
        try:
            start_date = datetime.utcnow() - timedelta(hours=hours)
            end_date = datetime.utcnow()

            return await self.find_by_date_range(
                date_field="created_at",
                start_date=start_date,
                end_date=end_date,
                limit=limit,
            )
        except Exception as e:
            raise RepositoryError(
                f"Failed to get recent signals for {hours} hours", original_error=e
            )

    async def get_signals_by_performance(
        self,
        min_pnl: Optional[Decimal] = None,
        max_pnl: Optional[Decimal] = None,
        limit: Optional[int] = None,
    ) -> List[Signal]:
        """Get signals filtered by performance criteria."""
        try:
            # Since PnL is calculated dynamically, we'll get all signals and filter in memory
            # In a production system, you might want to store calculated PnL values
            all_signals = await self.get_all(
                limit=limit * 2 if limit else None
            )  # Get more to filter

            filtered_signals = []
            for signal in all_signals:
                pnl = signal.get_pnl()

                if min_pnl is not None and pnl < min_pnl:
                    continue
                if max_pnl is not None and pnl > max_pnl:
                    continue

                filtered_signals.append(signal)

            # Sort by PnL descending
            filtered_signals.sort(key=lambda s: s.get_pnl(), reverse=True)

            if limit:
                filtered_signals = filtered_signals[:limit]

            return filtered_signals

        except Exception as e:
            raise RepositoryError(
                "Failed to get signals by performance", original_error=e
            )

    async def update_signal_status(self, signal_id: str, status: SignalStatus) -> bool:
        """Update the status of a specific signal."""
        try:
            signal = await self.get_by_id(signal_id)
            if not signal:
                return False

            signal.status = status
            signal.updated_at = datetime.utcnow()

            await self.update(signal)

            logger.info(f"Updated signal {signal_id} status to {status}")
            return True

        except Exception as e:
            raise RepositoryError(
                f"Failed to update signal status for {signal_id}", original_error=e
            )

    async def close_signal(
        self, signal_id: str, close_price: Decimal, close_time: datetime
    ) -> bool:
        """Close a signal with final price and time."""
        try:
            signal = await self.get_by_id(signal_id)
            if not signal:
                return False

            # Update current price to close price and close the signal
            signal.update_current_price(close_price)
            signal.close_signal(f"Closed at {close_time}")

            await self.update(signal)

            pnl = signal.get_pnl()
            logger.info(f"Closed signal {signal_id} at {close_price} with PnL: {pnl}")
            return True

        except Exception as e:
            raise RepositoryError(
                f"Failed to close signal {signal_id}", original_error=e
            )

    async def calculate_strategy_performance(self, strategy_id: str) -> Dict[str, Any]:
        """Calculate performance metrics for a strategy's signals."""
        try:
            # Get all filled signals for the strategy
            signals = await self.find_by_criteria(
                {"strategy_id": strategy_id, "status": SignalStatus.FILLED}
            )

            if not signals:
                return {
                    "total_signals": 0,
                    "winning_signals": 0,
                    "losing_signals": 0,
                    "win_rate": 0.0,
                    "total_pnl": 0.0,
                    "average_win": 0.0,
                    "average_loss": 0.0,
                    "profit_factor": 0.0,
                    "max_drawdown": 0.0,
                }

            total_signals = len(signals)
            winning_signals = [s for s in signals if s.get_pnl() > 0]
            losing_signals = [s for s in signals if s.get_pnl() < 0]

            total_pnl = sum(float(s.get_pnl()) for s in signals)
            win_rate = (
                (len(winning_signals) / total_signals) * 100 if total_signals > 0 else 0
            )

            avg_win = (
                sum(float(s.get_pnl()) for s in winning_signals) / len(winning_signals)
                if winning_signals
                else 0
            )
            avg_loss = (
                sum(float(s.get_pnl()) for s in losing_signals) / len(losing_signals)
                if losing_signals
                else 0
            )

            gross_profit = sum(float(s.get_pnl()) for s in winning_signals)
            gross_loss = abs(sum(float(s.get_pnl()) for s in losing_signals))
            profit_factor = (
                gross_profit / gross_loss
                if gross_loss > 0
                else float("inf") if gross_profit > 0 else 0
            )

            # Calculate max drawdown based on updated_at timestamp (since we don't have close_time)
            running_pnl = 0
            peak = 0
            max_drawdown = 0

            for signal in sorted(signals, key=lambda s: s.updated_at):
                running_pnl += float(signal.get_pnl())
                if running_pnl > peak:
                    peak = running_pnl
                drawdown = peak - running_pnl
                if drawdown > max_drawdown:
                    max_drawdown = drawdown

            return {
                "total_signals": total_signals,
                "winning_signals": len(winning_signals),
                "losing_signals": len(losing_signals),
                "win_rate": win_rate,
                "total_pnl": total_pnl,
                "average_win": avg_win,
                "average_loss": avg_loss,
                "profit_factor": profit_factor,
                "max_drawdown": max_drawdown,
            }

        except Exception as e:
            raise RepositoryError(
                f"Failed to calculate strategy performance for {strategy_id}",
                original_error=e,
            )
