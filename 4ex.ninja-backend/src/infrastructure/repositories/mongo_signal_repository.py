"""
MongoDB Signal Repository Implementation

Concrete implementation of ISignalRepository for MongoDB database operations.
Provides optimized queries and signal-specific data access methods.
"""

import logging
from typing import List, Optional, Dict, Any
from datetime import datetime, timedelta
from decimal import Decimal

from ...core.interfaces.signal_repository import ISignalRepository
from ...core.entities.signal import Signal, SignalType, SignalStatus
from .mongo_base_repository import MongoBaseRepository
from ...core.interfaces.repository import RepositoryError

# Set up logging
logger = logging.getLogger(__name__)


class MongoSignalRepository(MongoBaseRepository[Signal], ISignalRepository):
    """
    MongoDB implementation of signal repository.

    Provides optimized queries for signal-specific operations including
    filtering by strategy, pair, status, and performance metrics.
    """

    def __init__(self, database: Any, session: Optional[Any] = None):
        """
        Initialize the signal repository.

        Args:
            database: MongoDB database instance
            session: Optional MongoDB session for transactions
        """
        super().__init__(database, "signals", Signal, session)

    async def get_by_strategy_id(
        self, strategy_id: str, limit: Optional[int] = None
    ) -> List[Signal]:
        """Get all signals generated by a specific strategy."""
        try:
            return await self.find_by_criteria(
                {"strategy_id": strategy_id},
                limit=limit,
                sort_by="created_at",
                sort_order="desc",  # Newest first
            )
        except Exception as e:
            raise RepositoryError(
                f"Failed to get signals by strategy ID {strategy_id}", original_error=e
            )

    async def get_by_pair(self, pair: str, limit: Optional[int] = None) -> List[Signal]:
        """Get all signals for a specific currency pair."""
        try:
            return await self.find_by_criteria(
                {"pair": pair}, limit=limit, sort_by="created_at", sort_order="desc"
            )
        except Exception as e:
            raise RepositoryError(
                f"Failed to get signals by pair {pair}", original_error=e
            )

    async def get_by_status(
        self, status: SignalStatus, limit: Optional[int] = None
    ) -> List[Signal]:
        """Get all signals with a specific status."""
        try:
            return await self.find_by_criteria(
                {"status": status.value},
                limit=limit,
                sort_by="created_at",
                sort_order="desc",
            )
        except Exception as e:
            raise RepositoryError(
                f"Failed to get signals by status {status.value}", original_error=e
            )

    async def get_by_type(
        self, signal_type: SignalType, limit: Optional[int] = None
    ) -> List[Signal]:
        """Get all signals of a specific type."""
        try:
            return await self.find_by_criteria(
                {"signal_type": signal_type.value},
                limit=limit,
                sort_by="created_at",
                sort_order="desc",
            )
        except Exception as e:
            raise RepositoryError(
                f"Failed to get signals by type {signal_type.value}", original_error=e
            )

    async def get_active_signals(self, limit: Optional[int] = None) -> List[Signal]:
        """Get all currently active signals."""
        try:
            return await self.get_by_status(SignalStatus.ACTIVE, limit)
        except Exception as e:
            raise RepositoryError("Failed to get active signals", original_error=e)

    async def get_recent_signals(
        self, hours: int = 24, limit: Optional[int] = None
    ) -> List[Signal]:
        """Get signals generated within the last specified hours."""
        try:
            cutoff_time = datetime.utcnow() - timedelta(hours=hours)
            return await self.find_by_criteria(
                {"created_at": {"$gte": cutoff_time}},
                limit=limit,
                sort_by="created_at",
                sort_order="desc",
            )
        except Exception as e:
            raise RepositoryError(
                f"Failed to get recent signals for last {hours} hours", original_error=e
            )

    async def get_signals_by_performance(
        self,
        min_pnl: Optional[Decimal] = None,
        max_pnl: Optional[Decimal] = None,
        limit: Optional[int] = None,
    ) -> List[Signal]:
        """Get signals filtered by performance criteria."""
        try:
            filters = {}

            if min_pnl is not None:
                filters["realized_pnl"] = {"$gte": float(min_pnl)}

            if max_pnl is not None:
                if "realized_pnl" in filters:
                    filters["realized_pnl"]["$lte"] = float(max_pnl)
                else:
                    filters["realized_pnl"] = {"$lte": float(max_pnl)}

            return await self.find_by_criteria(
                filters,
                limit=limit,
                sort_by="realized_pnl",
                sort_order="desc",  # Best performance first
            )
        except Exception as e:
            raise RepositoryError(
                "Failed to get signals by performance criteria", original_error=e
            )

    async def update_signal_status(self, signal_id: str, status: SignalStatus) -> bool:
        """Update the status of a specific signal."""
        try:
            update_data = {"status": status.value, "updated_at": datetime.utcnow()}

            if status in [
                SignalStatus.FILLED,
                SignalStatus.CANCELLED,
                SignalStatus.EXPIRED,
            ]:
                update_data["closed_at"] = datetime.utcnow()

            result = await self.update_by_criteria(
                {"signal_id": signal_id}, update_data
            )

            logger.info(f"Updated signal {signal_id} status to {status.value}")
            return result > 0

        except Exception as e:
            raise RepositoryError(
                f"Failed to update signal {signal_id} status to {status.value}",
                original_error=e,
            )

    async def close_signal(
        self, signal_id: str, close_price: Decimal, close_time: datetime
    ) -> bool:
        """Close a signal with final price and time."""
        try:
            # First get the signal to calculate PnL
            signal = await self.get_by_id(signal_id)
            if not signal:
                logger.warning(f"Signal {signal_id} not found for closing")
                return False

            # Calculate realized PnL
            entry_price = signal.entry_price
            if signal.signal_type == SignalType.BUY:
                pnl = close_price - entry_price
            else:  # SELL
                pnl = entry_price - close_price

            update_data = {
                "status": SignalStatus.FILLED.value,
                "close_price": float(close_price),
                "close_time": close_time,
                "realized_pnl": float(pnl),
                "closed_at": datetime.utcnow(),
                "updated_at": datetime.utcnow(),
            }

            result = await self.update_by_criteria(
                {"signal_id": signal_id}, update_data
            )

            logger.info(f"Closed signal {signal_id} at {close_price} with PnL {pnl}")
            return result > 0

        except Exception as e:
            raise RepositoryError(
                f"Failed to close signal {signal_id}", original_error=e
            )
