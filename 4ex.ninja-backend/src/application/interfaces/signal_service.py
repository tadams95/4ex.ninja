"""
Signal Service Interface
Defines the interface for signal management and processing.
"""

from abc import ABC, abstractmethod
from typing import List, Optional, Dict, Any
from datetime import datetime
from decimal import Decimal

from ...core.entities.signal import Signal, SignalType, SignalStatus


class ISignalService(ABC):
    """
    Signal service interface for signal management and processing.
    """

    @abstractmethod
    async def create_signal(self, signal_data: Dict[str, Any]) -> Signal:
        """
        Create a new trading signal.

        Args:
            signal_data: Signal data

        Returns:
            Created signal
        """
        pass

    @abstractmethod
    async def get_signal(self, signal_id: str) -> Optional[Signal]:
        """
        Get signal by ID.

        Args:
            signal_id: Signal identifier

        Returns:
            Signal if found
        """
        pass

    @abstractmethod
    async def get_active_signals(self, pair: Optional[str] = None) -> List[Signal]:
        """
        Get all active signals.

        Args:
            pair: Optional currency pair filter

        Returns:
            List of active signals
        """
        pass

    @abstractmethod
    async def get_signals_by_strategy(
        self, strategy_id: str, limit: Optional[int] = None
    ) -> List[Signal]:
        """
        Get signals generated by a specific strategy.

        Args:
            strategy_id: Strategy identifier
            limit: Optional limit on number of signals

        Returns:
            List of signals
        """
        pass

    @abstractmethod
    async def get_signals_by_status(
        self, status: SignalStatus, limit: Optional[int] = None
    ) -> List[Signal]:
        """
        Get signals by status.

        Args:
            status: Signal status to filter by
            limit: Optional limit on number of signals

        Returns:
            List of signals
        """
        pass

    @abstractmethod
    async def update_signal_status(self, signal_id: str, status: SignalStatus) -> bool:
        """
        Update signal status.

        Args:
            signal_id: Signal identifier
            status: New status

        Returns:
            True if update successful
        """
        pass

    @abstractmethod
    async def close_signal(
        self,
        signal_id: str,
        close_price: Decimal,
        close_time: Optional[datetime] = None,
    ) -> bool:
        """
        Close a signal with final price and time.

        Args:
            signal_id: Signal identifier
            close_price: Closing price
            close_time: Closing time (defaults to now)

        Returns:
            True if signal closed successfully
        """
        pass

    @abstractmethod
    async def calculate_signal_pnl(self, signal: Signal) -> Decimal:
        """
        Calculate profit/loss for a signal.

        Args:
            signal: Signal to calculate PnL for

        Returns:
            Calculated PnL
        """
        pass

    @abstractmethod
    async def get_recent_signals(
        self, hours: int = 24, limit: Optional[int] = None
    ) -> List[Signal]:
        """
        Get recent signals within specified hours.

        Args:
            hours: Hours to look back
            limit: Optional limit on number of signals

        Returns:
            List of recent signals
        """
        pass

    @abstractmethod
    async def get_signals_by_performance(
        self,
        min_pnl: Optional[Decimal] = None,
        max_pnl: Optional[Decimal] = None,
        limit: Optional[int] = None,
    ) -> List[Signal]:
        """
        Get signals filtered by performance.

        Args:
            min_pnl: Minimum PnL filter
            max_pnl: Maximum PnL filter
            limit: Optional limit on number of signals

        Returns:
            List of signals matching criteria
        """
        pass

    @abstractmethod
    async def validate_signal(self, signal: Signal) -> Dict[str, Any]:
        """
        Validate a signal before processing.

        Args:
            signal: Signal to validate

        Returns:
            Validation results
        """
        pass

    @abstractmethod
    async def process_signal_queue(self) -> int:
        """
        Process pending signals in the queue.

        Returns:
            Number of signals processed
        """
        pass

    @abstractmethod
    async def expire_old_signals(self, max_age_hours: int = 24) -> int:
        """
        Expire old pending signals.

        Args:
            max_age_hours: Maximum age in hours before expiring

        Returns:
            Number of signals expired
        """
        pass

    @abstractmethod
    async def get_signal_statistics(
        self, time_period_days: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get signal statistics for a time period.

        Args:
            time_period_days: Time period in days (all time if None)

        Returns:
            Signal statistics
        """
        pass

    @abstractmethod
    async def duplicate_signal_check(self, signal: Signal) -> bool:
        """
        Check if a signal is a duplicate of existing signals.

        Args:
            signal: Signal to check

        Returns:
            True if signal is a duplicate
        """
        pass

    @abstractmethod
    async def get_signals_by_pair(
        self, pair: str, limit: Optional[int] = None
    ) -> List[Signal]:
        """
        Get signals for a specific currency pair.

        Args:
            pair: Currency pair
            limit: Optional limit on number of signals

        Returns:
            List of signals for the pair
        """
        pass

    @abstractmethod
    async def calculate_strategy_performance(self, strategy_id: str) -> Dict[str, Any]:
        """
        Calculate performance metrics for a strategy's signals.

        Args:
            strategy_id: Strategy identifier

        Returns:
            Performance metrics
        """
        pass
