"""
Signal-to-Discord Integration Module
Automatically sends Enhanced Daily Strategy signals to Discord when generated.

This module:
1. Monitors signal generation from Enhanced Daily Strategy
2. Determines appropriate Discord tier routing
3. Formats signals for Discord delivery
4. Tracks signal delivery success
5. Provides signal delivery analytics
"""

import asyncio
import logging
from datetime import datetime, timezone
from typing import Dict, Any, List, Optional

from services.enhanced_discord_service import (
    EnhancedDiscordService, 
    UserTier, 
    SignalPriority,
    get_enhanced_discord_service
)
from services.enhanced_daily_production_service import EnhancedDailyProductionService
from services.signal_service import SignalService


class SignalDiscordIntegration:
    """Integrates Enhanced Daily Strategy signals with Discord delivery."""

    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.discord_service = get_enhanced_discord_service()
        self.enhanced_daily_service = EnhancedDailyProductionService()
        self.signal_service = SignalService()
        
        # Signal delivery tracking
        self.delivery_tracking = {
            "signals_processed": 0,
            "signals_sent": 0,
            "delivery_failures": 0,
            "last_delivery": None,
            "tier_routing": {tier.value: 0 for tier in UserTier}
        }
        
        # Signal quality thresholds for tier routing
        self.tier_thresholds = {
            UserTier.FREE: {
                "min_confidence": 0.5,
                "min_confluence": 0.0,
                "allowed_pairs": ["USD_JPY", "EUR_USD", "GBP_USD"]  # Limited pairs
            },
            UserTier.PREMIUM: {
                "min_confidence": 0.6,
                "min_confluence": 0.5,
                "allowed_pairs": None  # All pairs
            },
            UserTier.WHALE: {
                "min_confidence": 0.7,
                "min_confluence": 0.8,
                "allowed_pairs": None  # All pairs with priority
            },
            UserTier.ALPHA: {
                "min_confidence": 0.8,
                "min_confluence": 1.0,
                "allowed_pairs": None  # All signals first
            }
        }

    async def process_and_send_signals(self) -> Dict[str, Any]:
        """
        Generate signals and automatically send to Discord.
        
        Returns:
            Processing summary with delivery results
        """
        try:
            self.logger.info("ðŸš€ Processing Enhanced Daily Strategy signals for Discord delivery...")
            
            # Generate enhanced signals
            signals_data = await self.enhanced_daily_service.generate_enhanced_signals()
            
            if not signals_data:
                self.logger.warning("No signals generated")
                return {
                    "status": "no_signals",
                    "signals_processed": 0,
                    "signals_sent": 0,
                    "message": "No signals generated by Enhanced Daily Strategy"
                }
            
            self.logger.info(f"Generated {len(signals_data)} enhanced signals")
            
            # Process each signal for Discord delivery
            delivery_results = []
            signals_sent_count = 0
            
            for signal_data in signals_data:
                try:
                    # Determine if signal should be sent
                    should_send, reasons = self._should_send_signal(signal_data)
                    
                    if should_send:
                        # Determine signal priority and tiers to send to
                        priority = self._determine_signal_priority(signal_data)
                        target_tiers = self._determine_target_tiers(signal_data)
                        
                        # Send to each appropriate tier
                        tier_results = {}
                        for tier in target_tiers:
                            success = await self.discord_service.send_enhanced_signal(
                                signal_data, tier, priority
                            )
                            tier_results[tier.value] = success
                            
                            if success:
                                self.delivery_tracking["tier_routing"][tier.value] += 1
                                signals_sent_count += 1
                        
                        delivery_results.append({
                            "pair": signal_data.get("pair"),
                            "recommendation": signal_data.get("trade_recommendation", {}).get("recommendation"),
                            "confidence": signal_data.get("trade_recommendation", {}).get("confidence", 0),
                            "priority": priority.value,
                            "tiers_sent": list(tier_results.keys()),
                            "tier_results": tier_results,
                            "sent_successfully": any(tier_results.values())
                        })
                        
                        # Update signal status if sent to any tier
                        if any(tier_results.values()):
                            # Create a signal ID for tracking
                            signal_id = f"enhanced_{signal_data.get('pair')}_{datetime.now().strftime('%H%M%S')}"
                            await self.signal_service.mark_signal_sent(signal_id)
                        
                    else:
                        delivery_results.append({
                            "pair": signal_data.get("pair"),
                            "recommendation": signal_data.get("trade_recommendation", {}).get("recommendation"),
                            "sent_successfully": False,
                            "skip_reasons": reasons
                        })
                    
                    self.delivery_tracking["signals_processed"] += 1
                    
                except Exception as e:
                    self.logger.error(f"Error processing signal for {signal_data.get('pair', 'UNKNOWN')}: {str(e)}")
                    self.delivery_tracking["delivery_failures"] += 1
            
            # Update tracking
            self.delivery_tracking["signals_sent"] += signals_sent_count
            self.delivery_tracking["last_delivery"] = datetime.now(timezone.utc).isoformat()
            
            # Create summary
            summary = {
                "status": "completed",
                "timestamp": datetime.now(timezone.utc).isoformat(),
                "signals_processed": len(signals_data),
                "signals_sent": signals_sent_count,
                "delivery_rate": (signals_sent_count / len(signals_data) * 100) if signals_data else 0,
                "delivery_results": delivery_results,
                "tier_distribution": self.delivery_tracking["tier_routing"].copy()
            }
            
            self.logger.info(f"âœ… Signal processing complete: {signals_sent_count}/{len(signals_data)} signals sent to Discord")
            
            return summary
            
        except Exception as e:
            self.logger.error(f"Error in signal processing: {str(e)}")
            self.delivery_tracking["delivery_failures"] += 1
            return {
                "status": "error",
                "error": str(e),
                "signals_processed": 0,
                "signals_sent": 0
            }

    def _should_send_signal(self, signal_data: Dict[str, Any]) -> tuple[bool, List[str]]:
        """
        Determine if a signal should be sent to Discord.
        
        Returns:
            (should_send, reasons_if_not)
        """
        reasons = []
        
        # Check if there's a valid trade recommendation
        trade_rec = signal_data.get("trade_recommendation", {})
        recommendation = trade_rec.get("recommendation", "WAIT")
        
        if recommendation in ["WAIT", "AVOID"]:
            reasons.append(f"Recommendation is {recommendation}")
            return False, reasons
        
        # Check minimum confidence
        confidence = trade_rec.get("confidence", 0.0)
        if confidence < 0.4:  # Minimum threshold for any Discord delivery
            reasons.append(f"Confidence too low: {confidence:.1%}")
            return False, reasons
        
        # Check if signal has sufficient quality
        signal_strength = signal_data.get("signal_strength", "weak")
        if signal_strength == "weak":
            reasons.append("Signal strength is weak")
            return False, reasons
        
        # All checks passed
        return True, []

    def _determine_signal_priority(self, signal_data: Dict[str, Any]) -> SignalPriority:
        """Determine signal priority based on quality metrics."""
        
        confidence = signal_data.get("trade_recommendation", {}).get("confidence", 0.0)
        confluence_score = signal_data.get("confluence_score", 0.0)
        signal_strength = signal_data.get("signal_strength", "weak")
        
        # Critical priority: Very high confidence, strong confluence, top strength
        if confidence >= 0.9 and confluence_score >= 1.5 and signal_strength == "confluence":
            return SignalPriority.CRITICAL
        
        # High priority: High confidence and good confluence
        if confidence >= 0.8 and confluence_score >= 1.0:
            return SignalPriority.HIGH
        
        # Medium priority: Good confidence or good confluence
        if confidence >= 0.7 or confluence_score >= 0.8:
            return SignalPriority.MEDIUM
        
        # Low priority: All others that pass minimum thresholds
        return SignalPriority.LOW

    def _determine_target_tiers(self, signal_data: Dict[str, Any]) -> List[UserTier]:
        """Determine which user tiers should receive this signal."""
        
        target_tiers = []
        
        pair = signal_data.get("pair", "")
        confidence = signal_data.get("trade_recommendation", {}).get("confidence", 0.0)
        confluence_score = signal_data.get("confluence_score", 0.0)
        
        # Check each tier's requirements
        for tier, thresholds in self.tier_thresholds.items():
            # Check confidence threshold
            if confidence < thresholds["min_confidence"]:
                continue
            
            # Check confluence threshold
            if confluence_score < thresholds["min_confluence"]:
                continue
            
            # Check allowed pairs (if restricted)
            if thresholds["allowed_pairs"] and pair not in thresholds["allowed_pairs"]:
                continue
            
            # Tier qualifies for this signal
            target_tiers.append(tier)
        
        # Ensure at least FREE tier gets decent signals
        if not target_tiers and confidence >= 0.6:
            target_tiers.append(UserTier.FREE)
        
        return target_tiers

    async def send_signal_batch_update(self) -> bool:
        """Send a batch update of all current signals to all tiers."""
        try:
            # Generate current signals
            signals_data = await self.enhanced_daily_service.generate_enhanced_signals()
            
            if not signals_data:
                return False
            
            # Filter signals that should be sent
            quality_signals = []
            for signal_data in signals_data:
                should_send, _ = self._should_send_signal(signal_data)
                if should_send:
                    quality_signals.append(signal_data)
            
            if not quality_signals:
                return False
            
            # Send batch updates to each tier
            batch_results = {}
            for tier in UserTier:
                # Filter signals appropriate for this tier
                tier_signals = []
                for signal_data in quality_signals:
                    target_tiers = self._determine_target_tiers(signal_data)
                    if tier in target_tiers:
                        tier_signals.append(signal_data)
                
                if tier_signals:
                    success = await self.discord_service.send_batch_enhanced_signals(
                        tier_signals, tier
                    )
                    batch_results[tier.value] = {
                        "signals_sent": len(tier_signals),
                        "success": success
                    }
                    
                    if success:
                        self.delivery_tracking["tier_routing"][tier.value] += len(tier_signals)
            
            self.logger.info(f"Batch signal update sent: {batch_results}")
            return True
            
        except Exception as e:
            self.logger.error(f"Error sending batch signal update: {str(e)}")
            return False

    async def send_performance_updates(self) -> bool:
        """Send performance updates to all tiers."""
        try:
            # Get performance metrics (you can integrate with your backtest results)
            performance_metrics = {
                "total_return": 522.91,
                "win_rate": 0.6087,
                "total_trades": 23,
                "profitable_trades": 14,
                "avg_trade_return": 22.7,
                "max_drawdown": -8.5,
                "sharpe_ratio": 2.15,
                "strategy": "Enhanced Daily Strategy Phase 1"
            }
            
            # Send to all tiers
            results = {}
            for tier in UserTier:
                success = await self.discord_service.send_performance_update(
                    performance_metrics, tier
                )
                results[tier.value] = success
            
            self.logger.info(f"Performance updates sent: {results}")
            return any(results.values())
            
        except Exception as e:
            self.logger.error(f"Error sending performance updates: {str(e)}")
            return False

    def get_delivery_analytics(self) -> Dict[str, Any]:
        """Get comprehensive delivery analytics."""
        
        total_processed = self.delivery_tracking["signals_processed"]
        total_sent = self.delivery_tracking["signals_sent"]
        
        return {
            "delivery_summary": {
                "signals_processed": total_processed,
                "signals_sent": total_sent,
                "delivery_failures": self.delivery_tracking["delivery_failures"],
                "success_rate": (total_sent / total_processed * 100) if total_processed > 0 else 0,
                "last_delivery": self.delivery_tracking["last_delivery"]
            },
            "tier_distribution": self.delivery_tracking["tier_routing"],
            "discord_service_stats": self.discord_service.get_delivery_stats(),
            "tier_thresholds": {
                tier.value: thresholds for tier, thresholds in self.tier_thresholds.items()
            }
        }

    async def test_integration(self) -> Dict[str, Any]:
        """Test the complete signal-to-Discord integration."""
        try:
            self.logger.info("ðŸ§ª Testing signal-to-Discord integration...")
            
            # Test 1: Generate signals
            signals_test = await self.enhanced_daily_service.generate_enhanced_signals()
            signals_generated = len(signals_test)
            
            # Test 2: Test Discord connectivity
            webhook_tests = await self.discord_service.test_all_webhooks()
            webhooks_working = sum(1 for result in webhook_tests.values() if result)
            
            # Test 3: Send test signal
            if signals_test:
                test_signal = signals_test[0]  # Use first signal for testing
                test_sent = await self.discord_service.send_enhanced_signal(
                    test_signal, UserTier.FREE, SignalPriority.MEDIUM
                )
            else:
                test_sent = False
            
            # Test 4: Send performance update
            test_performance = await self.send_performance_updates()
            
            # Compile results
            test_results = {
                "integration_test_status": "PASS" if all([
                    signals_generated > 0,
                    webhooks_working > 0,
                    test_sent,
                    test_performance
                ]) else "FAIL",
                "signals_generated": signals_generated,
                "webhooks_working": f"{webhooks_working}/{len(webhook_tests)}",
                "test_signal_sent": test_sent,
                "performance_update_sent": test_performance,
                "webhook_test_results": webhook_tests,
                "delivery_analytics": self.get_delivery_analytics()
            }
            
            self.logger.info(f"Integration test complete: {test_results['integration_test_status']}")
            return test_results
            
        except Exception as e:
            self.logger.error(f"Integration test failed: {str(e)}")
            return {
                "integration_test_status": "ERROR",
                "error": str(e)
            }


# Global integration service instance
signal_discord_integration = SignalDiscordIntegration()


def get_signal_discord_integration() -> SignalDiscordIntegration:
    """Get the signal-Discord integration service."""
    return signal_discord_integration


async def auto_send_signals():
    """Convenience function to automatically send current signals to Discord."""
    integration = get_signal_discord_integration()
    return await integration.process_and_send_signals()


async def test_discord_integration():
    """Convenience function to test the Discord integration."""
    integration = get_signal_discord_integration()
    return await integration.test_integration()
