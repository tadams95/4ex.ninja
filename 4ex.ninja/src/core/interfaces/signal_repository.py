"""
Signal Repository Interface - Domain-specific repository for Signal entities

This module defines the Signal repository interface with domain-specific
methods for Signal entity operations.
"""

from abc import abstractmethod
from typing import List, Optional, Dict, Any
from datetime import datetime
from decimal import Decimal

from .repository import IBaseRepository
from ..entities.signal import Signal, SignalType, SignalStatus


class ISignalRepository(IBaseRepository[Signal]):
    """
    Signal repository interface defining Signal-specific data access methods.

    Extends the base repository with domain-specific operations for Signal entities.
    """

    @abstractmethod
    async def get_by_strategy_id(
        self, strategy_id: str, limit: Optional[int] = None
    ) -> List[Signal]:
        """
        Get all signals generated by a specific strategy.

        Args:
            strategy_id: The strategy identifier
            limit: Maximum number of signals to return

        Returns:
            List of signals from the strategy
        """
        pass

    @abstractmethod
    async def get_by_pair(self, pair: str, limit: Optional[int] = None) -> List[Signal]:
        """
        Get all signals for a specific currency pair.

        Args:
            pair: The currency pair (e.g., "EUR_USD")
            limit: Maximum number of signals to return

        Returns:
            List of signals for the pair
        """
        pass

    @abstractmethod
    async def get_by_status(
        self, status: SignalStatus, limit: Optional[int] = None
    ) -> List[Signal]:
        """
        Get all signals with a specific status.

        Args:
            status: The signal status to filter by
            limit: Maximum number of signals to return

        Returns:
            List of signals with the specified status
        """
        pass

    @abstractmethod
    async def get_by_type(
        self, signal_type: SignalType, limit: Optional[int] = None
    ) -> List[Signal]:
        """
        Get all signals of a specific type.

        Args:
            signal_type: The signal type to filter by
            limit: Maximum number of signals to return

        Returns:
            List of signals of the specified type
        """
        pass

    @abstractmethod
    async def get_active_signals(self, limit: Optional[int] = None) -> List[Signal]:
        """
        Get all currently active signals.

        Args:
            limit: Maximum number of signals to return

        Returns:
            List of active signals
        """
        pass

    @abstractmethod
    async def get_recent_signals(
        self, hours: int = 24, limit: Optional[int] = None
    ) -> List[Signal]:
        """
        Get signals generated within the last specified hours.

        Args:
            hours: Number of hours to look back
            limit: Maximum number of signals to return

        Returns:
            List of recent signals
        """
        pass

    @abstractmethod
    async def get_signals_by_performance(
        self,
        min_pnl: Optional[Decimal] = None,
        max_pnl: Optional[Decimal] = None,
        limit: Optional[int] = None,
    ) -> List[Signal]:
        """
        Get signals filtered by performance criteria.

        Args:
            min_pnl: Minimum PnL to filter by
            max_pnl: Maximum PnL to filter by
            limit: Maximum number of signals to return

        Returns:
            List of signals matching performance criteria
        """
        pass

    @abstractmethod
    async def update_signal_status(self, signal_id: str, status: SignalStatus) -> bool:
        """
        Update the status of a specific signal.

        Args:
            signal_id: The signal identifier
            status: The new status

        Returns:
            True if update successful, False otherwise
        """
        pass

    @abstractmethod
    async def close_signal(
        self, signal_id: str, close_price: Decimal, close_time: datetime
    ) -> bool:
        """
        Close a signal with final price and time.

        Args:
            signal_id: The signal identifier
            close_price: The closing price
            close_time: The closing time

        Returns:
            True if signal closed successfully, False otherwise
        """
        pass

    @abstractmethod
    async def calculate_strategy_performance(self, strategy_id: str) -> Dict[str, Any]:
        """
        Calculate performance metrics for a strategy's signals.

        Args:
            strategy_id: The strategy identifier

        Returns:
            Dictionary containing performance metrics
        """
        pass
